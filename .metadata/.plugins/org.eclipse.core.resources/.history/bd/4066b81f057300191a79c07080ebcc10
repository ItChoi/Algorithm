# 06장 정렬
	- 정렬을 이용해 데이터를 정렬하면 검색을 더 쉽게 할 수 있다. 
	- 이 장에서는 정렬 알고리즘 중에서 대표적인 알고리즘 8개를 소개 한다. 이때 정렬 알고리즘은 안정된(stable) 알고리즘과
		그렇지 않은 알고리즘으로 나눌 수 있다. 안정된 알고리즘은 예를 들어, 학번 순, 점수 순 등으로 정렬된 것을 말하며 
		같은 점수인 경우 정렬되지 않은 것을 안정되지 않았다고 할 수 있다.
	- 내부 정렬과 외부 정렬
		1) 내부 정렬: 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
		2) 외부 정렬: 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘
		
		
### 06-2 버블 정렬
	- 버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.
	- 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.
		그리고 이러한 일련의 과정을 패스(pass)라고 한다. 두 번째 패스의 비교 횟수는 첫 번째 패스보다
		1회 적은 n - 2회 다. 왜냐하면 패스를 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문이다.
		
```
public class TestAlgorithm {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("버블 정렬(버전 1)");
		System.out.println("요솟수 : ");
		int nx = sc.nextInt();
		int[] x = new int[nx];
		
		for (int i = 0; i < nx; i++) {
			System.out.println("x[" + i + "]: ");
			x[i] = sc.nextInt();
		}
		
		bubbleSort(x, nx);
		
		System.out.println("오름차순으로 정렬했습니다.");
		
		for (int i = 0; i < nx; i++) {
			System.out.println("x[" + i + "]= " + x[i]);
		}
	}
	
	// a[idx1]와 a[idx2]의 값을 바꾼다.
	static void swap(int[] a, int idx1, int idx2) {
		int t = a[idx1];
		a[idx1] = a[idx2];
		a[idx2] = t;
	}
	
	// 버블 정렬
	static void bubbleSort(int[] a, int n) {
		for (int i = 0; i < n - 1; i++) {
			for (int j = n - 1; j > i; j--) {
				if (a[j - 1] > a[j]) {
					swap(a, j - 1, j);
				}
			}
		}
	}
	
}
```



##### 연습문제
Q1) 버블 정렬의 각 패스에서 비교, 교환은 처음(왼쪽)부터 수행해도 된다. 프로그램으로 만들어보세요.
	A1)
		// 버블 정렬
		static void bubbleSort(int[] a, int n) {
			for (int i = n - 1; i > 0; i--) {
				for (int j = 0; j < i; j++) {
					if (a[j] > a[j + 1]) {
						swap(a, j + 1, j);
					}
				}
			}
		}
	
Q2) 비교, 교환 과정을 자세히 출력하면서 버블 정렬하는 프로그램을 만들어보자. 교환 수행 시 두 숫자 사이에 +
	비교하지 않을 시 -를 출력하고 정렬을 마치면 비교 횟수와 교환 횟수 출력 (p.204)	
	A1)
		
		

	- 버블 정렬에서 패스가 끝나지 않았을 때 정렬이 다 되어 있다면 	더 이상 패스를 거치지 않아도 된다. (버블 정렬 개선 1)
	```
	static void bubbleSort(int[] a, int n) {
		for (int i = n - 1; i > 0; i--) {
			int count = 0;
			for (int j = 0; j < i; j++) {
				if (a[j] > a[j + 1]) {
					swap(a, j + 1, j);
					count++;
				}
			}
			
			if (count == 0) {	// 변환이 일어나지 않는다면 for문을 멈춘다.
				break;
			}
		}
	}
	```
	- 이미 정렬이 되어 있는 것들을 버블정렬 시키지 않기. ex) 1,3,4,9,6,7,8 -> 1,3,4 (버블 정렬 개선 2)
	```
	static void bubbleSort(int[] a, int n) {
		int k = 0;
		while (k < n - 1) {
			int last = n - 1;
			for (int i = n - 1; i > 0; i--) {
				swap(a, i - 1, i);
				last = i;
			}
			k = last;
		}
	}
	// last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소(a[i])의 인덱스를 저장하기 위한 변수다)
	```

##### 연습문제
Q5) 다음의 배열을 정렬한다고 가정 (9, 1, 3, 4, 6, 7, 8) - 이 배열은 두 번째 요소부터 정렬은 되어 있지만, 버블 정렬
	에서 빠른 시간 안에 정렬 작업을 마칠 수는 없다. 그래서 홀수 번째의 패스는 가장 작은 요소를 맨 앞으로 옮기고 짝수 번째 패스는
	가장 큰 요소를 맨 뒤로 옮기는 방식을 사용한다면 (패스의 스캔 방식을 교도래 바꾸면) 이런 정렬을 더 적은 횟수로 비교할 수 있다.
	(버블 정렬을 개선한 이 알고리즘은 양방향 버블 정렬, 칵테일 정렬, 셰이커 정렬이라는 이름으로 알려져 있다.)
	
	A5)
	```
	static void bubbleSort(int[] a, int n) {
		int left = 0;
		int right = n - 1;
		int last = right;
		
		while (left < right) {
			for (int i = right; i > left; i--) {
				swap(a, i - 1, i);
				last = i;
			}
			left = last;
			
			for (int i = left; i < right; i++) {
				swap(a, i, i + 1);
				last = i;
			}
			
			right = last;
		}
		
	}
	```
	
		
	
### 06-3 단순 선택 정렬
	- 단순 선택 정렬은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘이다.
	
	- 단순 선택 정렬의 교환 과정
		1) 아직 정렬하지 않은 부분에서 가장 작은 키의 값 (a[min])을 선택.
		2) a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환한다.
	
	- 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 (n2 - n) / 2 회이다. 그런데 이 알고리즘은 멀리 떨어져 있는
		요소를 교환하는 것이기 때문에 안정적이지 않다.
	
	```
	static void selectionSort(int[] a, int n) {
		for (int i = 0; i < n - 1; i++) {
			int min = i;
			
			for (int j = i + 1; j < n; j++) {
				if (a[j] < a[min]) {
					min = j;
				}
			}
			swap(a, i, min);
			
		}
	}
	```
	
		
### 06-4 단순 삽입 정렬		
	- 단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬한다.
	
	```
	static void insertionSort(int[] a, int n) {
		for (int i = 1; i < n; i++) {
			int j;
			int tmp = a[i];
			
			for (j = i; j > 0 && a[j-1] > tmp; j--) {
				a[j] = a[j-1];
			}
			
			a[j] = tmp;
		}
	}
	```
	
	- 이렇게 구현한 단순 삽입 정렬 알고리즘은 떨어져 잇는 요소들이 서로 뒤 바뀌지 않아 안정적이다.
		요소의 비교 횟수와 교환 횟수는 n2/ 2회 이다.
		
	- 단순 정렬의 시간 복잡도
		- 버블, 선택, 삽입 정렬의 시간 복잡도는 모두 O(n2) 이다. (효율이 좋지 않다.)
		
	
Q7) 단순 삽입 정렬에서 배열의 첫 번째 요소 (a[0])부터 데이터를 저장하지 않고 a[1]부터 데이터를 저장하면 a[0]을 보초로
	하여 삽입을 마치는 조건을 줄일 수 잇다. 이를 적용한 단순 삽입 정렬 메서드를 만드십쇼.
	
	A7) 예제 보고 따라함.. 잘 몰 겄다.
	// 단순삽입정렬(보초법：배열의 머리요소는 비어있습니다.)
	static void insertionSort(int[] a, int n) {
		for (int i = 2; i < n; i++) {
			int tmp = a[0] = a[i];
			int j = i;
			for (; a[j - 1] > tmp; j--)
				a[j] = a[j - 1];
			if (j > 0)
				a[j] = tmp;
		}
	}
	
	
Q8) 단순 삽입 정렬은 배열의 요솟수가 많아질수록 요소 삽입에 필요한 비교, 대입 비용이 무시할 수 없을 정도로 커진다. 이 때
	배열에서 이미 정렬된 부분은 이진 검색을 사용할 수 있기 때문에 삽입할 위치를 더 빨리 찾을 수 있다. 이진 검색을 사용하여
	프로그램을 수정하십쑈. (이진 삽입 정렬은 안정적이지 않다.)
	
	A8) 우와 헷갈린다..
	static void binInsertionSort(int[] a, int n) {
		for (int i = 1; i < n; i++) {
			int key = a[i];
			int pl = 0; // 검색범위 맨 앞의 인덱스
			int pr = i - 1; // 검색범위 맨 뒤의 인덱스
			int pc; // 〃 중앙의 인덱스
			int pd; // 삽입하는 위치의 인덱스

			do {
				pc = (pl + pr) / 2;
				if (a[pc] == key) // 검색성공
					break;
				else if (a[pc] < key)
					pl = pc + 1;
				else
					pr = pc - 1;
			} while (pl <= pr);
			pd = (pl <= pr) ? pc + 1 : pr + 1;

			for (int j = i; j > pd; j--)
				a[j] = a[j - 1];
			a[pd] = key;
		}
	}
	


### 06-5 셸 정렬
	- 셸 정렬은 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.
		먼저 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 구룹을 합치면서
		정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.
		
	ex) 1, 2, 3, 4, 5, 0, 6 배열에서 0을 정렬하려면 총 6회에 걸쳐 요소를 이동해야 한다.
	- 단순 삽입 정렬의 특징
		1) 장점: 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.
		2) 단점: 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.











