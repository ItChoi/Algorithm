# 06장 정렬
	- 정렬을 이용해 데이터를 정렬하면 검색을 더 쉽게 할 수 있다. 
	- 이 장에서는 정렬 알고리즘 중에서 대표적인 알고리즘 8개를 소개 한다. 이때 정렬 알고리즘은 안정된(stable) 알고리즘과
		그렇지 않은 알고리즘으로 나눌 수 있다. 안정된 알고리즘은 예를 들어, 학번 순, 점수 순 등으로 정렬된 것을 말하며 
		같은 점수인 경우 정렬되지 않은 것을 안정되지 않았다고 할 수 있다.
	- 내부 정렬과 외부 정렬
		1) 내부 정렬: 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
		2) 외부 정렬: 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘
		
		
### 06-2 버블 정렬
	- 버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.
	- 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.
		그리고 이러한 일련의 과정을 패스(pass)라고 한다. 두 번째 패스의 비교 횟수는 첫 번째 패스보다
		1회 적은 n - 2회 다. 왜냐하면 패스를 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문이다.
		
```
public class TestAlgorithm {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("버블 정렬(버전 1)");
		System.out.println("요솟수 : ");
		int nx = sc.nextInt();
		int[] x = new int[nx];
		
		for (int i = 0; i < nx; i++) {
			System.out.println("x[" + i + "]: ");
			x[i] = sc.nextInt();
		}
		
		bubbleSort(x, nx);
		
		System.out.println("오름차순으로 정렬했습니다.");
		
		for (int i = 0; i < nx; i++) {
			System.out.println("x[" + i + "]= " + x[i]);
		}
	}
	
	// a[idx1]와 a[idx2]의 값을 바꾼다.
	static void swap(int[] a, int idx1, int idx2) {
		int t = a[idx1];
		a[idx1] = a[idx2];
		a[idx2] = t;
	}
	
	// 버블 정렬
	static void bubbleSort(int[] a, int n) {
		for (int i = 0; i < n - 1; i++) {
			for (int j = n - 1; j > i; j--) {
				if (a[j - 1] > a[j]) {
					swap(a, j - 1, j);
				}
			}
		}
	}
	
}
```



##### 연습문제
Q1) 버블 정렬의 각 패스에서 비교, 교환은 처음(왼쪽)부터 수행해도 된다. 프로그램으로 만들어보세요.
	A1)
		// 버블 정렬
		static void bubbleSort(int[] a, int n) {
			for (int i = n - 1; i > 0; i--) {
				for (int j = 0; j < i; j++) {
					if (a[j] > a[j + 1]) {
						swap(a, j + 1, j);
					}
				}
			}
		}
	
Q2) 비교, 교환 과정을 자세히 출력하면서 버블 정렬하는 프로그램을 만들어보자. 교환 수행 시 두 숫자 사이에 +
	비교하지 않을 시 -를 출력하고 정렬을 마치면 비교 횟수와 교환 횟수 출력 (p.204)	
	A1)
		
		

	- 버블 정렬에서 패스가 끝나지 않았을 때 정렬이 다 되어 있다면 	더 이상 패스를 거치지 않아도 된다. (버블 정렬 개선 1)
	```
	static void bubbleSort(int[] a, int n) {
		for (int i = n - 1; i > 0; i--) {
			int count = 0;
			for (int j = 0; j < i; j++) {
				if (a[j] > a[j + 1]) {
					swap(a, j + 1, j);
					count++;
				}
			}
			
			if (count == 0) {	// 변환이 일어나지 않는다면 for문을 멈춘다.
				break;
			}
		}
	}
	```
	- 이미 정렬이 되어 있는 것들을 버블정렬 시키지 않기. ex) 1,3,4,9,6,7,8 -> 1,3,4 (버블 정렬 개선 2)
	```
	static void bubbleSort(int[] a, int n) {
		int k = 0;
		while (k < n - 1) {
			int last = n - 1;
			for (int i = n - 1; i > 0; i--) {
				swap(a, i - 1, i);
				last = i;
			}
			k = last;
		}
	}
	// last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소(a[i])의 인덱스를 저장하기 위한 변수다)
	```

##### 연습문제
Q5) 다음의 배열을 정렬한다고 가정 (9, 1, 3, 4, 6, 7, 8) - 이 배열은 두 번째 요소부터 정렬은 되어 있지만, 버블 정렬
	에서 빠른 시간 안에 정렬 작업을 마칠 수는 없다. 그래서 홀수 번째의 패스는 가장 작은 요소를 맨 앞으로 옮기고 짝수 번째 패스는
	가장 큰 요소를 맨 뒤로 옮기는 방식을 사용한다면 (패스의 스캔 방식을 교도래 바꾸면) 이런 정렬을 더 적은 횟수로 비교할 수 있다.
	(버블 정렬을 개선한 이 알고리즘은 양방향 버블 정렬, 칵테일 정렬, 셰이커 정렬이라는 이름으로 알려져 있다.)
	
	A5)
	```
	static void bubbleSort(int[] a, int n) {
		int left = 0;
		int right = n - 1;
		int last = right;
		
		while (left < right) {
			for (int i = right; i > left; i--) {
				swap(a, i - 1, i);
				last = i;
			}
			left = last;
			
			for (int i = left; i < right; i++) {
				swap(a, i, i + 1);
				last = i;
			}
			
			right = last;
		}
		
	}
	```
	
		
	
### 06-3 단순 선택 정렬
	- 단순 선택 정렬은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘이다.
	
	- 단순 선택 정렬의 교환 과정
		1) 아직 정렬하지 않은 부분에서 가장 작은 키의 값 (a[min])을 선택.
		2) a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환한다.
	
	- 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 (n2 - n) / 2 회이다. 그런데 이 알고리즘은 멀리 떨어져 있는
		요소를 교환하는 것이기 때문에 안정적이지 않다.
	
	
		
### 06-4 단순 삽입 정렬		