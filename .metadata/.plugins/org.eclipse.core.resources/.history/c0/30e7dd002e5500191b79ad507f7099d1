# 05장 재귀

##### 직접 재귀와 간접 재귀
	- 직접(direct) 재귀: 메서드 내부에서 다시 메서드를 호출하는 것 처럼 자신과 같은 메서드를 호출
	- 간접(indirect) 재귀: 메서드 a가 메서드 b를 호출하고, 다시 메서드 b가 메서드 a를 호출하는 구조
	
##### 유클리드 호제법
	- A를 B로 나눈 나머지가 C일 때 (A와 B의 최대공약수) = (B와 C의 최대공약수) 라는 사실을 이용하여 
	처음에 구하려고 했던 숫자의 크기를 점점 줄여 간단하게 만든 다음 최대공약수를 구하는 방법
```
public static int gcd(int x, int y) {
	if (y == 0) {
		return x;
	} else 
		return gcd(y, x % y);
	}
}
```	

##### 연습문제
Q1) 재귀 메서드 호출을 사용하지 않고 팩토리얼(!10) 메서드작성
```
	A1)
	public static int factorial(int n) {
		int sum = 1;
		for (int i = 1; i <= n; i++) {
			sum *= i;
		}
		
		return sum;
	}
```	
Q2) 재귀 메서드 호출을 사용하지 않고 위 gcd 메서드 작성
```
	A2)
	public static int gcd(int x, int y) {
		int temp = 0;
		while (y != 0) {
			temp = x;
			x = y;
			y = temp % y;
		}
		
		return x;
	}
```	
Q3) 배열 a의 모든 요소의 최대공약수를 구하는 메서드 작성
	ex) static int gcdArray(int[] a)
```	
	A3)
	public static void main(String[] args) {
		
		int[] a = {80, 400, 160, 240};
		System.out.println(gcdArray(a));
		
	}
	
	static int gcdArray(int[] a) {
		int result = 0;
		
		for (int i = 0; i < a.length - 1; i++) {
			result = gcd(a[i], a[i + 1]);
		}
		
		return result;
	}
	
	static int gcd(int x, int y) {
		if (y == 0) {
			return x;
		} else {
			return gcd(y, x % y);
		}
	}
```


##### 05-2 재귀 알고리즘 분석
```
static void recur(int n) {
		if (n > 0) {
			recur(n - 1);
			System.out.println("n: " + n);
			recur(n - 2);
		}
	}
```		
	- recur 메서드는 안에서 재귀 호출을 2회 실행한다. int n의 값을 4로 준다면 1 2 3 1 4 1 2 가 나온다.
	이처럼 재귀 호출을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라 하며, 실제 동작은 매우 복잡하다.
	이런 복잡한 구조를 가진 재귀 메서드는 좀 더 전략적으로 분석해야 한다. 여기서 하향식과 상향식 방식의 분석이 있다.
		1) 하향식 분석
			- 매개변수 n으로 4를 전달하면 recur 메서드는 아래 과정을 순서대로 실행한다.
				- recur(3) 실행
				- 4를 출력
				- recur(2)를 실행
			
			물론 4를 출력하는 것은 recur(3) 실행이 완료된 다음이다.
			메서드 호출부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석이라 한다.
		
		2) 상향식 분석
			- 아래쪽부터 쌓아 올리며 분석하는 방법
			- recur 메서드는 n이 양수일 때 실행하므로 recur(1)을 예시로 들면
				- recur(0)을 실행
				- 1을 출력
				- recur(-1)을 실행
			
			여기서 recur(0)과 recur(-1)은 출력할 내용이 없다. 따라서 1만 출력한다.
			그럼 recur(2)에 대해 다시 생각해보자.
				- recur(1)을 실행
				- 2를 출력
				- recur(0)을 실행

##### 재귀 알고리즘의 비재귀적 표현
	- recur(n - 2)라는 말은 '인자로 n - 2를 전달하여 recur 메서드를 호출한다'는 의미이다.
	ex)
	static void recur(int n) {
		while (n > 0) {
			recur(n - 1);
			System.out.println("n: " + n);
			n = n - 2;
		}
	}

	우선 이렇게 하면 메서드의 끝에서 실행하는 꼬리 재귀(tail recursion)는 쉽게 제거할 수 있다.	
? 하 어렵다 이해가 잘 안가네


				
	

