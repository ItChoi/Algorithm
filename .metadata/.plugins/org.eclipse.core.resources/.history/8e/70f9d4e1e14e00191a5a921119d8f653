# 01장

### 01-1 알고리즘이란?
	
	ex)
	Scanner stdIn = new Scanner(System.in);
	- stdIn은 키보드와 연결된 표준 입력 스트림(System.in)에서 문자나 숫자를 꺼내는 장치 역할을 한다.
	
##### 연습문제
Q1) 네 값의 최대 값을 구하는 max4 메서드를 작성하세요.
	- static int max4(int a, int b, int c, int d)

	A1)
	```class
	public static int max4(int a, int b, int c, int d) {
		int max = a;
		
		if (b > max) {
			max = b;
		} 
		
		if (c > max) {
			max = c;
		} 
		
		if (d > max) {
			max = d;
		}
		
		return max;
	}
	}
	```
	

Q2) 세 값의 최솟값을 구하는 min3 메서드를 작성하세요.
	- static int min3(int a, int b, int c)
	
	A2)
	```class
	public static int min3(int a, int b, int c) {
		int min = a;
		
		if (b < min) {
			min = b;
		} 
		
		if (c < min) {
			min = c;
		} 
		
		return min;
	}
	```
	
	
	
Q3) 네 값의 최솟값을 구하는 min4 메서드를 작성하세요.
	- static int min4(int a, int b, int c, int d)
	
	A3)
	```class
	public static int min4(int a, int b, int c, int d) {
		int min = a;
		
		if (b < min) {
			min = b;
		} 
		
		if (c < min) {
			min = c;
		} 
		
		if (d < min) {
			min = d;
		} 
		
		return min;
	}
	```
	
	
##### 실습 1C-1 세 값의 중앙값 구하기. (세 값의 대소 관계의 조합읜 13가지 종류가 있다. 해보기.)
	ex) static int med3(int a, int b, int c)
	
	A1)
	```class
	public static int med3(int d, int dd, int ddd) {
		int val = 0;
		
		int a = 3; int b = 3; int c = 3;
		
		
		if (a >= b) {
			
			if (b >= c) {
				val = b;
			} else if (a > c) {
				val = c;
			} else {
				val = a;
			}
			
		} else if(b > c) {
			
			if (a > c) {
				val = a;
			} else {
				val = c;
			}
			
		} else {
			val = b;
		}
		
		System.out.println("val: " + val);
		
		return val;
	}
	```
	
##### 연습문제

Q8) 1부터 10까지의 합은 (1 + 10) * 5와 같은 방법으로 구할 수 있다. 가우스의 덧셈이라는 방법을 이용해보자.
	A8) 
	```class
	int n = 31;
	int i = 1;
	int sum = 0;
	
	sum = (i + n) * n / 2;
	
	System.out.println(sum);
	```
	
##### % 드모르간 법칙
	- 각 조건을 부정하고 논리곱을 논리합으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 조건과 같다.
		ex) x && y와 !(!x || !y)는 같다.
		ex) x || y와 !(!x && !y)는 같다.
		
		
##### 연습문제
Q12) 곱셈표 형식에 맞게 출력하는 프로그램 작성 (구분선은 수직선 기호(|), 마이너스 기호(-), 플러스 기호(+) 사용

	A12)
	```class
	System.out.print("   |");
	for (int a = 1; a <= 9; a++) {
		System.out.printf("%3d", a);
	}
	System.out.println("\n---+---------------------------");
	
	for (int i = 1; i <= 9; i++) {
		System.out.printf("%3d|", i);
		
		for (int j = 1; j <= 9; j++) {
			System.out.printf("%3d", i * j);
		}
		
		System.out.println();
	}
	```
	
Q16) n 단의 피라미드를 출력하는 메서드 작성
	ex) static void spira(int n)
	```class
	static void spira(int n) {
		
		int index = 0;
		for (int i = 1; i <= n; i++) {
			
			for (int j = i; j <= n; j++) {
				System.out.print(" ");
			}
			
			for (int k = 1; k <= index + i; k++) {
				System.out.print("*");
			}
			
			index++;
			System.out.println();
		}
		
	}
	```
	


### 02-1 배열
	##### 자료구조: 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계, 데이터 단위는 데이터를 구성하는 한 덩어리라고 생각하면 된다.
	 쉽게 말해  자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다.  
	 
	 % 배열은 같은 자료형의 변수로 이루어진 구성요소(component)가 모인 것이다.
	 
	 1) 사용 방법
	 ```class
	 int[] a;
	 int a[];
	 int[] a = new int[5];
	 int[] a = new int[] {1, 2, 3, 4, 5};	
	 int[] a = {1, 2, 3, 4, 5};
	```
	2) 배열의 복제(클론)
	```class
	int[] a = {1, 2, 3, 4, 5};
	int[] b = a.clone();
	
	b[3] = 0;
	// a = 1 2 3 4 5
	// b = 1 2 3 0 5
	```
	
##### 연습문제
Q2) 배열 요소 역순으로 정렬
	A2)
	```class
	int[] a = {1, 2, 3 , 4, 5};
	int temp;
	
	int leng = a.length;
	
	for (int i = 0; i < leng / 2; i++) {
		temp = a[i];
		a[i] = a[leng - i - 1];
		a[leng - i - 1] = temp;
		
	}
	```
	
Q5) 배열 b의 모든 요소를 배열 a에 역순으로 복사하는 메서드 rcopy 완성
	ex) static void rcopy(int[] a, int[] b)
	```class
	public static void rcopy(int[] a, int[] b) {
		int temp;
		int mid;
		
		int leng = a.length;
		
		for (int i = 0; i < (leng % 2 == 0 ? leng / 2 : leng / 2 + 1); i++) {
			
			temp = a[i];
			b[i] = a[leng - i - 1];
			b[leng - i - 1] = temp;
		}
		
		for (int aaa : b) {
			System.out.println("aaaa: " + aaa);
		}
		
	}
	```
	
	%%%% 한 해의 경과 일 수를 계산하는 프로그램
	```class
	// 각 달의 일수 (평년/윤년)
	static int[][] mdays = {
			{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
			{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	};
	
	// 서기 year년은 윤년인가(윤년: 1 / 평년: 0)
	static int isLeap(int year) {
		return (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) ? 1 : 0;
	}
	
	// 서기 y년 m월 d일의 그 해 경과 일 수를 구함.
	static int dayOfYear(int y, int m, int d) {
		int days = d;
		
		for (int i = 1; i < m; i++) {
			days +=	mdays[isLeap(y)][i - 1];
		}
		return days;
		
	}
	
	
	public static void main(String[] args) {
		int year = 2018;
		int month = 11;
		int day = 21;
		
		
		System.out.println("일 수: " + dayOfYear(year, month, day));
	}
	```
	

##### 연습문제
Q8) 메서드 dayOfYear를 변수 i와 days없이 구현 (while 사용)
	A8)
	```class
	static int[][] mdays = {
			{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
			{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	};
	
	static int isLeap(int year) {
		return (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) ? 1 : 0;
	}
	
	static int dayOfYear(int y, int m, int d) {
		
		while (--m != 0) {
			d += mdays[isLeap(y)][m - 1];
		}
		
		return d;
	}
	
	
	public static void main(String[] args) {
		int y = 2018;
		int m = 11;
		int d = 21;
		System.out.println("일 수: " + dayOfYear(y, m, d));
			
	}
	```
	
	 
# 03 장 검색

### 03-1 검색 알고리즘

	1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행한다.
	2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행한다.
	3. 해시법: 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행한다.
		- 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
		- 오픈 주소법: 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법	 
		
	% 데이터 집합에 대한 검색뿐 아니라 데이터의 추가, 삭제 등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여
	알고리즘을 선택해야 한다. 따라서 용도나 목적, 실행 속도, 자료구조 등을 고려하여 알고리즘을 선택해야 한다.



### 03-2 선형 검색
	- 요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하면 되는데,
	이것을 선형 검색(linear search) 또는 순차 검색(sequential search)이라는 알고리즘이다.
	- 선형 검색의 종료 조건을 보면 1) 검색할 값을 발견하지 못하고 배열의 끝을 지난 경우 2) 검색할 값과 같은 요소를 발견한 경우 종료한다.
	
```class
	public static void main(String[] args) {
		int[] x = {5, 1, 2, 7, 9 ,4};
		int ky = 7;
		int num = x.length;
		
		int idx = seqSearch(x, num, ky);
		
		if (idx == -1) {
			
		} else {
			System.out.println(ky + "는 x[" + idx + "]에 있습니다.");
		}
		
	}
	
	public static int seqSearch(int[] x, int num, int ky) {
		
		for (int i = 0; i < num; i++) {
			if (x[i] == ky) {
				return i;
			} 
		}
		
		return -1;
	}
```

% 보초법
ex) int[] a = {6,4,3,2,1,3,8,2}; int[] b = {6,4,3,2,1,3,7,5};
배열 [0] ~ [6]은 초기에 준비해놓은 데이터이다. 검색하기 전에 검색하고자 하는 키 값을 맨 끝 요소에 저장한다(2, 5) 이때 저장하는 값을
보초(sentinel)라고 한다. 보초는 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역할을 한다.
```class
static int seqSearchSen(int[] a, int length, key) {
	int i = 0;
	a[n] = key;
	
	while(true) {
		if (a[i] == key) {
			break;
		i++;
		}
	}
	return i == n ? -1 : i; // 보초 값 판단을 위해 i와 n이면 검색 실패임을 나타내는 -1 반환
}
```




### 03-3 이진 검색
	- 데이터가 키 값으로 이미 정렬(오름차순 및 내림차순)되어 있다. 이진 검색은 선형 검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.
	ex) int[] a = {5, 7, 15, 28, 29, 31, 39, 58, 68, 70, 95};   int key = 39;
	검색하려는 값인 39는 a[5] (31)보다 큰 값이다 그러므로 대상을 a[6] ~ a[10]으로 좁힐 수 있다. 그러고 나서 검색 범위의
	중앙에 위치한 a[8]이 원하는 값인지 확인한다. 이를 반복! (중앙 위치는 start Index + end Index / 2)
	
	- 이진 검색의 경우 1) a[중앙 위치]와 key가 일치하는 경우, 2) 검색 범위가 더 이상 없는 경우 종료된다.
	
```class
	public static int search(int[] a, int key) {
		int s = 0;
		int l = a.length - 1;
		
		int m = 0;
		
		do {
			m = (s + l) / 2;
			
			if (key == a[m]) {
				return m;
			} else if (key > a[m]) {
				s = m + 1;
			} else {
				l = m;
			}
			
		} while(s <= l);
		
		return -1;
	}
```

##### 복잡도
	- 프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
	알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.
		1) 시간 복잡도(time complexity): 실행에 필요한 시간을 평가한 것
		2) 공간 복잡도(space complexity): 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
		
		
##### 연습 문제
Q1) for문을 이용하여 보초법을 사용해보기.
	A1)
	```class
	public static int test(int[] a, int key) {
		
		int result = 0;
		for (int i = 0; i < a.length; i++) {
			if (key == a[i]) {
				result = i;
				break;
			}
		}
		
		return result == a.length- 1 ? -1 : result;
	}
	``` 	
	
	
Q2) 아래 선형 검색의 스캐닝 과정을 상세히 출력하는 프로그램 작성하시오. 이때 각 행의 맨 왼쪽에 현재 검색하는
요소의 인덱스를 출력하고, 현재 검색하고 있는 요소 위에 별표 기호 *를 출력하시오.
```
	|  0  1  2  3  4  5  6
----+-----------------------
    |  *
   0|  6  4  3  2  1  9  8
    |
    |     *
   1|  6  4  3  2  1  9  8
    |
    |        *
   2|  6  4  3  2  1  9  8
   
   3은 x[2]에 있습니다.
```
	A2)
	```class
		int[] a = {6, 4, 3, 2, 1, 9, 8};
		int key = 3;
		
		int result = 0;
		
		System.out.print("   |");
		for (int i = 0; i < a.length; i++) {
			System.out.printf("%2d", i);
		}
		System.out.println("\n---+-----------------");
		
		for (int i = 0; i < a.length; i++) {
			
			System.out.print("   |");
			for (int j = 0; j <= i; j++) {
				if (j == 0) {
					System.out.print(" ");
				} else {
					System.out.print("  ");
				}
			}
			System.out.println("*");
			
			System.out.print(i + "  |");
			
			for (int j = 0; j < a.length; j++) {
				System.out.printf("%2d", a[j]);
			}
			System.out.println();
			
			if (a[i] == key) {
				result = i;
				break;
			}
			
		}
		
		System.out.println("key는 x[" + result + "]에 있습니다.");
	```
% 코드가 너무 더럽다........... 고민을 하고 리팩토링 해보기! 다음에.........................



Q3) 요솟수가 n인 배열 a에서 key와 일치하는 모든 요소의 인덱스를 배열 idx의 맨 앞부터 순서대로 저장하고, 일치한 요솟수를 반환하는
메서드를 작성하세요. 예를 들어 요솟수가 8인 배열 a의 요소가 {1,9,2,9,4,6,7,9}이고 key가 9면 배열 idx에 {1,3,7}을 저장하고 3을 반환
	ex) static searchIdx(int[] a, int n, int key, int[] idx)

	A3) 
	```class
	static int[] searchIdx(int[] a, int n, int key, int[] idx) {
		
		int index = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] == key) {
				idx[index++] = i;
			}
		}
		
		return idx;
	}
	```


```
	|  0  1  2  3  4  5  6
----+ <-        +        ->
   3|  1  2  3  5  6  8  9
    | <-  +  ->
   1|  1  2  3  5  6  8  9
   
   2는 x[1]에 있습니다.
```
Q4) 위쪽처럼 이진 검색의 과정을 자세히 출력하는 프로그램을 작성하세요. 각 행의 맨 왼쪽에 현재 검색하고 있는 요소의 인덱스를 출력하고,
검색 범위의 맨 앞 요소 위에 <-, 맨 끝 요소 위에 ->, 현재 검색하고 있는 중앙 요소 위에 +를 출력하세요.
 









