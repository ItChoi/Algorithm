# 05장 재귀

##### 직접 재귀와 간접 재귀
	- 직접(direct) 재귀: 메서드 내부에서 다시 메서드를 호출하는 것 처럼 자신과 같은 메서드를 호출
	- 간접(indirect) 재귀: 메서드 a가 메서드 b를 호출하고, 다시 메서드 b가 메서드 a를 호출하는 구조
	
##### 유클리드 호제법
	- A를 B로 나눈 나머지가 C일 때 (A와 B의 최대공약수) = (B와 C의 최대공약수) 라는 사실을 이용하여 
	처음에 구하려고 했던 숫자의 크기를 점점 줄여 간단하게 만든 다음 최대공약수를 구하는 방법
```
public static int gcd(int x, int y) {
	if (y == 0) {
		return x;
	} else 
		return gcd(y, x % y);
	}
}
```	

##### 연습문제
Q1) 재귀 메서드 호출을 사용하지 않고 팩토리얼(!10) 메서드작성
```
	A1)
	public static int factorial(int n) {
		int sum = 1;
		for (int i = 1; i <= n; i++) {
			sum *= i;
		}
		
		return sum;
	}
```	
Q2) 재귀 메서드 호출을 사용하지 않고 위 gcd 메서드 작성
```
	A2)
	public static int gcd(int x, int y) {
		int temp = 0;
		while (y != 0) {
			temp = x;
			x = y;
			y = temp % y;
		}
		
		return x;
	}
```	
Q3) 배열 a의 모든 요소의 최대공약수를 구하는 메서드 작성
	ex) static int gcdArray(int[] a)
```	
	A3)
	public static void main(String[] args) {
		
		int[] a = {80, 400, 160, 240};
		System.out.println(gcdArray(a));
		
	}
	
	static int gcdArray(int[] a) {
		int result = 0;
		
		for (int i = 0; i < a.length - 1; i++) {
			result = gcd(a[i], a[i + 1]);
		}
		
		return result;
	}
	
	static int gcd(int x, int y) {
		if (y == 0) {
			return x;
		} else {
			return gcd(y, x % y);
		}
	}
```


##### 05-2 재귀 알고리즘 분석
		
	
